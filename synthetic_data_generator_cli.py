# -*- coding: utf-8 -*-
'''
SYNTHETIC_DATA_GENERATOR_CLI
COMMANDLINE SCRIPT TO GENERATE SYNTHETIC TRXYT FILES USED FOR NANOSCALE SPATIOTEMPORAL INDEXING CLUSTERING (NASTIC AND SEGNASTIC) OR 3D DBSCAN (BOOSH).

Design and coding: Tristan Wallis and Alex McCann
Queensland Brain Institute
The University of Queensland
Fred Meunier: f.meunier@uq.edu.au

REQUIRED:
Python 3.8 or greater
python -m pip install numpy scipy matplotlib

INPUT (optional):
[1] roi_coordinates.tsv file - ROI file previously generated by NASTIC/segNASTIC/BOOSH
Used in SYNTHETIC to determine the selection area of the synthetic data that is to be generated
If no NASTIC roi_coordinates.tsv file is loaded, the selection area will instead be determined using the x-axis size (um) and y-axis size (um) parameters

Tab separated: ROI# x(um) y(um)
1 header

example:

ROI	x(um)	y(um)
0	4.736320240957679	26.616510133253666
0	4.765490026694448	26.616510133253666
0	4.794659812431218	26.616510133253666
0	4.823829598167988	26.645679918990435
0	4.852999383904757	26.645679918990435
0	4.882169169641527	26.645679918990435
etc

OUTPUT:
[1] .trxyt files - used as input files for NASTIC/segNASTIC/BOOSH
File naming format: synthetic_YYYYMMDD-HHMMSS.trxyt
Space separated: Trajectory X(um) Y(um) T(sec)  
No headers

example: 

1 9.0117 39.86 0.02
1 8.9603 39.837 0.04
1 9.093 39.958 0.06
1 9.0645 39.975 0.08
2 9.1191 39.932 0.1
2 8.9266 39.915 0.12
etc

[2] metrics.tsv files - contain the parameters that were selected by the user, and the metrics that were generated from these parameters which are then used to generate the .trxyt file. 
No NASTIC ROI file loaded: X-AXIS SIZE (um) and Y-AXIS SIZE (um) parameters are included in the metrics file. 
NASTIC ROI file loaded: the name of the ROI file (ROI FILE) and selection area (ROI AREA) are included in the metrics file. 
File naming format: synthetic_YYYYMMDD-HHMMSS_metrics.tsv

example:

PARAMETERS:
==========
ACQUISITION TIME (s): 320
FRAME TIME (s): 0.02
X-AXIS SIZE (um): 10 	
Y-AXIS SIZE (um): 10
ROI FILE: C:/Documents/PYTHON/20230215_roi_coordinates.tsv
ROI AREA: 726.94
SEED DENSITY (per um2): 2
SEED RADIUS (um): 0.1
MIN TRAJ AROUND SEED: 4
MAX TRAJ AROUND SEED: 12
MIN TRAJ STEPS: 5
MAX TRAJ STEPS: 30
MAX STEPLENGTH (um): 0.1
CLUSTER TRAJ ORBIT: True
NOISE FACTOR: 5
UNCLUST STEPLENGTH MULTIPLIER: 2.0
HOTSPOT PROBABILITY: 0.2
MAX CLUSTERS PER HOTSPOT: 3

GENERATED METRICS:
=================
TOTAL TRAJECTORIES: 1895
CLUSTERED TRAJECTORIES: 895
UNCLUSTERED TRAJECTORIES: 1000
TOTAL CLUSTERS: 110
SINGLETON CLUSTERS: 80
AVERAGE TRAJECTORIES PER CLUSTER: 8.136363636363637 +/- 0.2358306132306391
AVERAGE CLUSTER RADIUS: 0.08004795415240253 +/- 0.0009018811959358476

Generated .trxyt files [1] and corresponding metrics.tsv files [2] are saved within the same directory as the  synthetic_data_generator_gui.py script, in a folder that is created with the naming format: synthetic_data_output_YYYYMMDD-HHMMSS

USAGE: 
1 - Copy this script to the top level directory containing the files you are interested in, and run it (either by double clicking or navigating to the location of the script in the terminal and using the command 'python synthetic_data_generator_cli.py')
2 - Press x followed by the enter key to define the selection area using a pretend x,y frame size, or press n followed by the enter key to define the selection area using a previously saved NASTIC roi_coordinates.tsv file
3 - Using NASTIC ROI file: A list of roi_coordinates.tsv files found in the current directory and all subdirectories will be generated
4 - Using NASTIC ROI file: press the number corresponding to the roi_coordinates.tsv file that you wish to use as the ROI followed by the enter key
5 - Generated .trxyt files and metrics.tsv files will be saved in a datestamped folder
6 - Hit the return key to generate another file, or press Ctrl-c to exit the program

CHECK FOR UPDATES:
https://github.com/tristanwallis/smlm_clustering/releases
'''

lastchanged = "20240730"

# LOAD MODULES 
import numpy as np
import os
import glob
import random
import datetime
from scipy.spatial import ConvexHull
import math
from matplotlib import path

# VARS
acquisition_time = 320 # pretend length of acquisition (default 320)
frame_time = 0.02 # sec (default 0.02)
seed_density = 2 # how many cluster seeds per um2 of selection area (default 2)
min_traj_num = 4 # min number of trajectories around each seed (default 4)
max_traj_num = 12 # max number of trajectories around each seed (default 12)
x_size = 10 # pretend microns (default 10)
y_size = 10 # pretend microns (default 10)
min_traj_length = 5 # min number of trajectory steps (default 5)
max_traj_length = 30 # max number of trajectory steps (default 30)
radius = 0.1 # radius around each seed to make trajectories (um) (default 0.1)
steplength = 0.1 # maximum step length within trajectory (um) (default 0.1)
noise_factor = 5 # number of unclustered noise trajectories per seed (default 5)
unconst = 4 # steplength multiplier of unclustered trajectories (default 4)
hotspotprobability = 0.2 # chance of a given seed point generating multiple spatially overlapping but temporally distinct clusters (default 0.2)
hotspotmax = 3 # maximum number of temporal clusters at a given hotspot (default 3)
orbit = True # clustered trajectories orbit their spawn point rather than random walking (default True)
clusterdict = {} # dictionary holding clusters

# CONVEX HULL OF EXTERNAL POINTS, AND THEN INTERNAL POINTS
def double_hull(points):
	# Get the hull of the original points
	all_points = np.array(points)
	ext_hull = ConvexHull(all_points)
	ext_area = ext_hull.volume
	vertices = ext_hull.vertices
	vertices = np.append(vertices,vertices[0])
	ext_x = [all_points[vertex][0] for vertex in vertices]
	ext_y = [all_points[vertex][1] for vertex in vertices]
	ext_points = np.array(all_points[ext_hull.vertices])
		
	# Get the hull of the points inside the hull
	int_points = np.array([x for x in all_points if x not in ext_points])
	try:
		int_hull = ConvexHull(int_points)
		int_area = int_hull.volume
		vertices = int_hull.vertices
		vertices = np.append(vertices,vertices[0])
		int_x = [int_points[vertex][0] for vertex in vertices]
		int_y = [int_points[vertex][1] for vertex in vertices]
	except:
		int_x,int_y,int_area = ext_x,ext_y,ext_area
	return ext_x,ext_y,ext_area,int_x,int_y,int_area

# ROI AREA	
def PolyArea(x,y):
	return 0.5*np.abs(np.dot(x,np.roll(y,1))-np.dot(y,np.roll(x,1)))	

# OBTAIN POINTS BETWEEN TWO TRAJECTORY COORDINATES
def obtain_midpoints(trajx_before,trajy_before,x,y):
	midpoint_x_list = []
	midpoint_y_list = []
	midpoint_x = (x-trajx_before)/7
	midpoint_y = (y-trajy_before)/7
	for i in range(1,7):
		point_x = trajx_before + (i*midpoint_x)
		midpoint_x_list.append(point_x)
		point_y = trajy_before + (i*midpoint_y)
		midpoint_y_list.append(point_y)
	midpoint_list = zip(midpoint_x_list,midpoint_y_list)
	return(midpoint_list)
		
# READ ROI FILE	
def read_roi(roi_file):
	global selarea, p, allx, ally, selverts, roidict
	print ("\nDetermining selection area")
	print("------------------------------------------------------------")
	print("NASTIC ROI file selected: \n{}".format(roi_file))
	print("Reading ROI file...")
	roidict = {}
	allx = []
	ally = []
	with open (roi_file,"r") as infile:
		for line in infile:
			spl = line.split("\t")
			try:
				roi = int(spl[0])
				x = float(spl[1])
				y = float(spl[2])
				allx.append(x)
				ally.append(y)
				try:
					roidict[roi].append([x,y])
				except:	
					roidict[roi] = []
					roidict[roi].append([x,y])
			except:
				pass
	for roi in roidict:			
		selverts =roidict[roi]		
	p = path.Path(selverts)
	selarea =PolyArea(list(zip(*selverts))[0],list(zip(*selverts))[1])
	print("ROI selection area: {} um2".format(selarea))
	return()
	
######################################################

# RUN IT

# Initial directory
cwd = os.path.dirname(os.path.abspath(__file__))
os.chdir(cwd)
initialdir = cwd

# User input
os.system('cls' if os.name == 'nt' else 'clear')
try:
	while {True}:
		print ("SYNTHETIC DATA GENERATOR CLI - Tristan Wallis {}\n-----------------------------------------------------------".format(lastchanged))
		print ("Ctrl-c to quit at any time\n")
		
		# SELECTION AREA
		files = []
		selection_area_defined = False
		while selection_area_defined == False:
			selection_area = input ("Determine selection area using:\t[x]y frame size or [n]astic ROI file\n")
			if selection_area == "x" or selection_area == "X":
				files = True
				Load_ROI = False
				selection_area_defined = True
				
			elif selection_area == "n" or selection_area == "N":
			
				# Recursively find all files
				
				files = glob.glob(cwd + '/**/*roi_coordinates*.tsv',recursive=True)
				if len(files) == 0:
					print("\nALERT: No NASTIC roi_coordinates.tsv files were found in this directory.\n")
					Load_ROI = True
					selection_area_defined = False
				elif len(files) >=1:
					if len(files) == 1:
						print ("\n1 NASTIC roi_coordinates.tsv file found in this directory:")
						for n, file in enumerate(files, start=1):
							print ("\t[{}] {}".format(n,file))
					else:
						print("\n{} NASTIC roi_coordinates.tsv files found in this directory:".format(len(files)))
						for n, file in enumerate(files, start=1):
							print("\t[{}] {}".format(n,file))
			
					# Select files
					select_files = None
					while select_files == None:
						select_files_input = input("\nSelect file:")		
						if select_files_input == "":
							print("ALERT: '{input}' is not an accepted input, please enter the number associated with the file of interest\n".format(input = select_files_input))
						else:
							try:
								select_files = select_files_input.replace(" ","")
								filenums = select_files.split(",")
								if "0" in filenums:
									filenums.remove("0")
								if len(filenums) == 0:
									print("ALERT: File number is not in list, please enter a file number from the list\n")
									select_files = None
								elif len(filenums) >1:
									print("ALERT: Please select one file from the list\n")
									select_files = None
								else:
									filenums = [int(x) -1 for x in filenums]
									infilenames = [files[x] for x in filenums]
									selection_area_defined = True
							except ValueError:
								print("ALERT: '{input}' is not an accepted input, please enter the number associated with the file of interest\n".format(input = select_files_input))
								select_files = None
							except:
								print("ALERT: File number is not in list, please enter a file number from the list\n")
								select_files = None
					
					for roi_file in infilenames:
						read_roi(roi_file)
						Load_ROI = True
					selection_area_defined = True
			
		if selection_area_defined == True:
			print("\nGenerating trajectories")
			print("------------------------------------------------------------")
			# SEEDS
			seeds = []
			
			# Using NASTIC ROI to define selection area
			if Load_ROI == True:
				seed_num=int(seed_density*(round(selarea,0)))
				noise = seed_num * noise_factor
				print ("Generating {} spatiotemporal cluster seeds ({} seeds/um2)...".format(seed_num,seed_density))
				xmin = min(allx)
				xmax = max(allx)
				ymin = min(ally)
				ymax = max(ally)
				ct = 0
				while ct < seed_num:
					x = random.uniform(xmin,xmax) # random x
					y = random.uniform(ymin,ymax) # random y
					t = random.random()*acquisition_time # random t
					if p.contains_point([x,y]):
						seeds.append([x,y,t])
						ct +=1
			
			# Using x_size and y_size to define selection area
			elif Load_ROI == False:
				seed_num = seed_density*(round(x_size*y_size,0))
				noise = seed_num * noise_factor
				print ("Generating {} spatiotemporal cluster seeds ({} seeds/um2)...".format(seed_num, seed_density))
				ct = 0
				while ct < seed_num:
					x = random.random()*x_size # random x
					y = random.random()*y_size # random y
					t = random.random()*acquisition_time # random t
					seeds.append([x,y,t])
					ct +=1
			
			# TRAJECTORIES
			print ("Generating trajectories around cluster seeds...")
			clustercounter = 0
			clusttrajcounter = 0
			trajectories = []
			for seed in seeds:
				# Original cluster at each seed point
				clustercounter+=1
				x_seed,y_seed,t_seed = seed[0],seed[1],seed[2] # x, y and t for this cluster
				trajnum = random.randint(min_traj_num,max_traj_num) # number of trajectories for this cluster
				clusterdict[clustercounter]={"trajectories":[]} # empty trajectory dictionary for this cluster
				for j in range(trajnum):
					x_orig = x_seed + 0.5*(random.uniform(-radius,radius)) # starting x point for trajectory 
					y_orig = y_seed + 0.5*(random.uniform(-radius,radius))# starting y point for trajectory
					t = round((t_seed + (random.random()*10))/2,2)*2 # starting time, within 10 sec of the cluster t 
					traj_length = random.randint(min_traj_length,max_traj_length) # steps for this trajectory
					x = x_orig
					y = y_orig
		
					# Using NASTIC ROI to define selection area
					if Load_ROI == True:
						traj = []
						ct = 0
						try_ct = 1
						point_ct = 0				
						while ct < traj_length:
							if try_ct == 1000:
								x_orig = x_seed + 0.5*(random.uniform(-radius,radius)) # starting x point for trajectory 
								y_orig = y_seed + 0.5*(random.uniform(-radius,radius))# starting y point for trajectory
								x = x_orig
								y = y_orig
								traj = []
								ct = 0
								try_ct = 1
								point_ct = 0
							#Orbit
							if orbit:
								# Random walk constrained around spawn point
								x = x_orig  + 0.5*(random.uniform(-steplength,steplength))
								y = y_orig  + 0.5*(random.uniform(-steplength,steplength))
								if p.contains_point([x,y]):	
									if ct > 0:	
										trajx_before = traj[ct-1][0]
										trajy_before = traj[ct-1][1]
										midpoint_list = obtain_midpoints(trajx_before,trajy_before,x,y)
										midpointlistct = 0
										for x_midpoint,y_midpoint in midpoint_list:
											midpointlistct += 1
											if p.contains_point([x_midpoint,y_midpoint]):
												point_ct +=1
										if point_ct == 6:
											t += frame_time
											traj.append([x,y,t])
											ct += 1
											try_ct = 1
											point_ct = 0
										else:
											point_ct = 0
											try_ct += 1
									else:
										t = seed[2]
										traj.append([x,y,t])
										ct += 1
								else:
									try_ct +=1
							#No orbit
							else:	
								# Random walk unconstrained, can wander from spawn point
								prevx = x
								prevy = y
								x += 0.5*(random.uniform(-steplength,steplength))	
								y += 0.5*(random.uniform(-steplength,steplength))	
								if p.contains_point([x,y]):
									if ct > 0:	
										trajx_before = traj[ct-1][0]
										trajy_before = traj[ct-1][1]
										midpoint_list = obtain_midpoints(trajx_before,trajy_before,x,y)
										midpointlistct = 0
										for x_midpoint,y_midpoint in midpoint_list:
											midpointlistct += 1
											if p.contains_point([x_midpoint,y_midpoint]):
												point_ct +=1
										if point_ct == 6:
											t += frame_time
											traj.append([x,y,t])
											ct += 1
											try_ct = 1
											point_ct = 0
										else:
											point_ct = 0
											try_ct += 1
											x = prevx
											y = prevy
									else:
										t = seed[2]
										traj.append([x,y,t])
										ct += 1
								else:
									try_ct +=1
									x = prevx 
									y = prevy
							
						trajectories.append(traj)
						clusttrajcounter +=1
						clusterdict[clustercounter]["trajectories"].append(traj)
					
					# Using x_size and y_size to define selection area
					elif Load_ROI == False:
						traj = []
						ct = 0
						try_ct = 1
						while ct < traj_length:
							if try_ct == 1000:
								traj = []
								x_orig = x_seed + 0.5*(random.uniform(-radius,radius))
								y_orig = y_seed + 0.5*(random.uniform(-radius,radius))
								x = x_orig
								y = y_orig
								ct = 0
								try_ct = 1
							
							# Orbit
							if orbit:	
								# Random walk constrained around spawn point
								x = x_orig  + 0.5*(random.uniform(-steplength,steplength))
								y = y_orig  + 0.5*(random.uniform(-steplength,steplength))	
								if x < x_size and x > 0 and y < y_size and y > 0:
									t += frame_time
									traj.append([x,y,t])
									ct += 1
									try_ct = 1
								else:
									try_ct += 1	
							
							# No orbit
							else:	
								# Random walk unconstrained, can wander from spawn point
								prevx = x
								prevy = y
								x += 0.5*(random.uniform(-steplength,steplength))
								y += 0.5*(random.uniform(-steplength,steplength))	
								if x < x_size and x > 0 and y < y_size and y > 0:
									t += frame_time
									traj.append([x,y,t])
									ct += 1
									try_ct = 1
								else:
									try_ct += 1	
									x = prevx
									y = prevy
									
						trajectories.append(traj)
						clusttrajcounter +=1
						clusterdict[clustercounter]["trajectories"].append(traj)
					
				# Spatially overlapping, temporally distinct clusters at each seed point 
				if random.random() < hotspotprobability:
					for k in range(0,random.randint(1,hotspotmax-1)):
						clustercounter+=1
						clusterdict[clustercounter]={"trajectories":[]}
						x_seed = seed[0]+ random.uniform(-0.25,0.25)*radius # hotspot cluster x
						y_seed = seed[1]+ random.uniform(-0.25,0.25)*radius # hotspot cluster y
						t_seed = random.random()*acquisition_time
						trajnum = random.randint(min_traj_num,max_traj_num)
						for tr in range(trajnum):
							x_orig = x_seed + 0.5*(random.uniform(-radius,radius))
							y_orig = y_seed + 0.5*(random.uniform(-radius,radius))
							t = round((t_seed + (random.random()*10))/2,2)*2
							traj_length = random.randint(min_traj_length,max_traj_length)
							traj = []
							x = x_orig
							y = y_orig
							
							# Using NASTIC ROI to define selection area
							if Load_ROI == True:
								ct = 0
								try_ct = 1
								while ct < traj_length:
									if try_ct == 1000:
										traj = []
										ct = 0
										x_orig = x_seed + 0.5*(random.uniform(-radius,radius))
										y_orig = y_seed + 0.5*(random.uniform(-radius,radius))
										x = x_orig
										y = y_orig
										try_ct = 1
									
									# Orbit
									if orbit:
										# Random walk constrained around spawn point
										prevx = x
										prevy = y
										x = x_orig  + 0.5*(random.uniform(-steplength,steplength))
										y = y_orig  + 0.5*(random.uniform(-steplength,steplength))
										if p.contains_point([x,y]):	
											t += frame_time
											traj.append([x,y,t])
											ct += 1
											try_ct = 1
										else:
											try_ct += 1
											x = prevx
											y = prevy
									
									#No orbit
									else:
										# Random walk unconstrained, can wander from spawn point
										prevx = x
										prevy = y
										x += 0.5*(random.uniform(-steplength,steplength))	
										y += 0.5*(random.uniform(-steplength,steplength))
									if p.contains_point([x,y]):	
										t += frame_time
										traj.append([x,y,t])
										ct += 1
										try_ct = 1
									else:
										try_ct += 1
										x = prevx
										y = prevy
										
								trajectories.append(traj)
								clusttrajcounter +=1				
								clusterdict[clustercounter]["trajectories"].append(traj)
							
							# Using x_size and y_size to define selection area
							elif Load_ROI == False:
								ct = 0
								try_ct = 1
								while ct < traj_length:
									if try_ct == 1000:
										traj = []
										x_orig = x_seed + 0.5*(random.uniform(-radius,radius))
										y_orig = y_seed + 0.5*(random.uniform(-radius,radius))
										x = x_orig
										y = y_orig
										ct = 0
										try_ct = 1
									
									# Orbit
									if orbit:
										# Random walk constrained around spawn point
										x = x_orig  + 0.5*(random.uniform(-steplength,steplength))
										y = y_orig  + 0.5*(random.uniform(-steplength,steplength))
										if x < x_size and x > 0 and y < y_size and y > 0:
											t += frame_time
											traj.append([x,y,t])
											ct += 1
											try_ct = 1
										else:
											try_ct += 1
									
									# No orbit
									else:
										# Random walk unconstrained, can wander from spawn point
										prevx = x
										prevy = y
										x += 0.5*(random.uniform(-steplength,steplength))	 
										y += 0.5*(random.uniform(-steplength,steplength))
										if x < x_size and x > 0 and y < y_size and y > 0:
											t += frame_time
											traj.append([x,y,t])
											ct += 1
											try_ct = 1
										else:
											try_ct += 1
											x = prevx
											y = prevy
											
								trajectories.append(traj)
								clusttrajcounter +=1				
								clusterdict[clustercounter]["trajectories"].append(traj)
								
			# Noise		
			print ("Generating unclustered trajectory seeds...")
			
			# Using NASTIC ROI to define selection area
			if Load_ROI == True:
				noiseseeds = []
				ct = 0
				while ct < noise:
					x = random.uniform(xmin,xmax) # random x
					y = random.uniform(ymin,ymax) # random y
					t = random.random()*acquisition_time # random t
					if p.contains_point([x,y]):
						noiseseeds.append([x,y,t])
						ct +=1
				print ("Generating {} unclustered trajectories with higher mobility ({}x number of cluster seeds)...".format(noise, noise_factor))
				for seed in noiseseeds:
					x,y,t = seed[0],seed[1],seed[2] # x, y and t for this cluster
					traj_length = random.randint(min_traj_length,max_traj_length) # steps for this trajectory
					traj = []
					ct = 0
					try_ct = 1
					point_ct = 0
					while ct < traj_length:
						if try_ct == 1000:
							traj = []
							ct = 0
							x,y,t = seed[0],seed[1],seed[2]
							try_ct = 1
							point_ct = 0
						prevx = x
						prevy = y
						x += 0.5*unconst*(random.uniform(-steplength,steplength))	
						y += 0.5*unconst*(random.uniform(-steplength,steplength))	
						if p.contains_point([x,y]):	
							if ct > 0:	
								trajx_before = traj[ct-1][0]
								trajy_before = traj[ct-1][1]
								midpoint_list = obtain_midpoints(trajx_before,trajy_before,x,y)
								midpointlistct = 0
								for x_midpoint,y_midpoint in midpoint_list:
									midpointlistct += 1
									if p.contains_point([x_midpoint,y_midpoint]):
										point_ct +=1
								if point_ct == 6:
									t += frame_time
									traj.append([x,y,t])
									ct += 1
									try_ct = 1
									point_ct = 0
								else:
									x = prevx
									y = prevy
									point_ct = 0
									try_ct +=1
							else:
								t = seed[2]
								traj.append([x,y,t])
								ct += 1
						else:
							try_ct+=1
							x = prevx
							y = prevy
					
					trajectories.append(traj)
			
			# Using x_size and y_size to define selection area
			elif Load_ROI == False:
				noiseseeds = []
				ct = 0
				while ct < noise:
					x = random.random()*x_size # random x
					y = random.random()*y_size # random y
					t = random.random()*acquisition_time # random t
					noiseseeds.append([x,y,t])
					ct += 1
				print ("Generating {} unclustered trajectories with higher mobility ({}x number of cluster seeds)...".format(noise, noise_factor))
				for seed in noiseseeds:
					x,y,t = seed[0],seed[1],seed[2] # x, y and t for this cluster
					traj_length = random.randint(min_traj_length,max_traj_length) # steps for this trajectory
					traj = []
					ct = 0
					try_ct = 1
					while ct < traj_length:
						if try_ct == 1000:
							traj = []
							x,y,t = seed[0],seed[1],seed[2]
							ct = 0
							try_ct = 1
						# Random walk unconstrained, can wander from spawn point
						prevx = x
						prevy = y
						x += 0.5*unconst*(random.uniform(-steplength,steplength))		
						y += 0.5*unconst*(random.uniform(-steplength,steplength))
						if x < x_size and x > 0 and y < y_size and y > 0:
							t += frame_time	
							traj.append([x,y,t])
							ct += 1
							try_ct = 1
						else:
							try_ct +=1
							x = prevx
							y = prevy
							
					trajectories.append(traj)		
					
			# Metrics
			print("\nGenerating metrics")
			print("-----------------------------------------------------------")
			traj_nums = []
			radii= []
			for num in clusterdict:
				cluster_trajectories = clusterdict[num]["trajectories"]
				clusterdict[num]["traj_num"]=len(cluster_trajectories) # number of trajectories in each cluster
				clusterpoints = [point[:2]  for traj in cluster_trajectories for point in traj] # all x,y points for trajectories in cluster 
				ext_x,ext_y,ext_area,int_x,int_y,int_area = double_hull(clusterpoints) # internal and external convex hull of cluster points 
				clusterdict[num]["area"] = int_area # internal hull area as cluster area (um2)
				clusterdict[num]["radius"] = math.sqrt(int_area/math.pi) # radius of cluster internal hull (um)
				traj_nums.append(clusterdict[num]["traj_num"])
				radii.append(clusterdict[num]["radius"])
			print ("Total traj:",clusttrajcounter + noise)
			print ("Clustered traj:",clusttrajcounter)
			print ("Total clusters:", clustercounter)
			print ("Avg traj per cluster:", np.average(traj_nums))
			print ("Avg cluster radius:", np.average(radii))

			# Output
			print("\nWriting files")
			print("------------------------------------------------------------")
			stamp = '{:%Y%m%d-%H%M%S}'.format(datetime.datetime.now()) # datestamp
			os.mkdir("synthetic_data_output_{}".format(stamp))
			print ("Writing TRXYT...")
			with open("synthetic_data_output_{}/synthetic_data_{}.trxyt".format(stamp, stamp),"w") as outfile: 
				for tr,traj in enumerate(trajectories,start=1):
					for seg in traj:
						x,y,t = seg
						outline = "{} {} {} {}\n".format(tr,x,y,t)
						outfile.write(outline)
			print ("Writing metrics...")
			with open("synthetic_data_output_{}/synthetic_{}_metrics.tsv".format(stamp,stamp),"w") as outfile: 
				outfile.write("PARAMETERS:\n==========\n")
				outfile.write("ACQUISITION TIME (s): {}\n".format(acquisition_time))	
				outfile.write("FRAME TIME (s): {}\n".format(frame_time))	
				if Load_ROI == True:
					outfile.write("ROI FILE: {}\n".format(roi_file))	
					outfile.write("ROI AREA: {}\n".format(selarea))	
				if Load_ROI == False:
					outfile.write("X SIZE (um): {}\n".format(x_size ))	
					outfile.write("Y SIZE (um): {}\n".format(y_size))	
				outfile.write("SEED DENSITY (per um2): {}\n".format(seed_density))	
				outfile.write("SEED RADIUS (um): {}\n".format(radius))	
				outfile.write("MIN TRAJ AROUND SEED: {}\n".format(min_traj_num))	
				outfile.write("MAX TRAJ AROUND SEED: {}\n".format(max_traj_num))	
				outfile.write("MIN TRAJ STEPS: {}\n".format(min_traj_length))	
				outfile.write("MAX TRAJ STEPS: {}\n".format(max_traj_length))
				outfile.write("MAX STEPLENGTH (um): {}\n".format(steplength))	
				outfile.write("CLUSTER TRAJ ORBIT: {}\n".format(orbit))	
				outfile.write("NOISE FACTOR: {}\n".format(noise_factor))	
				outfile.write("UNCLUST STEPLENGTH MULTIPLIER: {}\n".format(unconst))	
				outfile.write("HOTSPOT PROBABILITY: {}\n".format(hotspotprobability))	
				outfile.write("MAX CLUSTERS PER HOTSPOT: {}\n".format(hotspotmax))	

				outfile.write("\nGENERATED METRICS:\n=================\n")
				outfile.write("TOTAL TRAJECTORIES: {}\n".format(clusttrajcounter + noise))
				outfile.write("CLUSTERED TRAJECTORIES: {}\n".format(clusttrajcounter))	
				outfile.write("UNCLUSTERED TRAJECTORIES: {}\n".format(noise))	
				outfile.write("TOTAL CLUSTERS: {}\n".format(clustercounter))
				outfile.write("SINGLETON CLUSTERS: {}\n".format(seed_num))
				outfile.write("AVERAGE TRAJECTORIES PER CLUSTER: {} +/- {}\n".format(np.average(traj_nums),np.std(traj_nums)/math.sqrt(len(traj_nums))))	
				outfile.write("AVERAGE CLUSTER RADIUS: {} +/- {}\n".format(np.average(radii),np.std(radii)/math.sqrt(len(radii))))	
				
				print("TRXYT and metrics files saved to: \n{}".format(cwd) + "\\synthetic_data_output_{}".format(stamp) + "\n")
			cont = input("\nDone!\n\nReturn key: Generate another file\nCtrl-c: Exit\n\n")
			
except KeyboardInterrupt:
	print("Exiting...")
	exit()